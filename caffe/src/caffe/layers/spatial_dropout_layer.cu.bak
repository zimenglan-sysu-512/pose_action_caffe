#include <algorithm>
#include <limits>
#include <vector>

#include "caffe/common.hpp"
#include "caffe/layer.hpp"
#include "caffe/syncedmem.hpp"
#include "caffe/vision_layers.hpp"
#include "caffe/util/math_functions.hpp"
#include "caffe/pose_estimation_layers.hpp"

namespace caffe {

template <typename Dtype>
void SpatialDropoutLayer<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
    const vector<Blob<Dtype>*>& top) {
  const Dtype* bottom_data = bottom[0]->gpu_data();
  Dtype* top_data = top[0]->mutable_gpu_data();

  if(this->phase_ == TRAIN) {
    const int num = bottom[0]->num();
    const int count = bottom[0]->count();
    const int sub_count = count / num;
    const int mask_count = rand_vec_.count();
    CHECK_EQ(num, mask_count);
    CHECK_EQ(count, num * sub_count);

    unsigned int* mask = static_cast<unsigned int*>(rand_vec_.mutable_gpu_data());
    caffe_gpu_rng_uniform(mask_count, mask);
    caffe_copy(mask_count, rand_vec_.gpu_data(), rand_vec_.mutable_cpu_data());

    for(int n = 0; n < num; n++) {
      const int offset = bottom[0]->offset(n);
      const Dtype alpha = Dtype((rand_vec_.cpu_data()[n] > uint_thres_) * scale_);
      caffe_gpu_scale(sub_count, alpha, bottom_data + offset, top_data + offset);
    }
  } else if(this->phase_ == TEST) {
    caffe_copy(bottom[0]->count(), bottom_data, top_data);
  } else {
    NOT_IMPLEMENTED;
  }
}

template <typename Dtype>
void SpatialDropoutLayer<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
    const vector<bool>& propagate_down,
    const vector<Blob<Dtype>*>& bottom) {
  if (propagate_down[0]) {
    const Dtype* top_diff = top[0]->gpu_diff();
    Dtype* bottom_diff = bottom[0]->mutable_gpu_diff();

    if(this->phase_ == TRAIN) {
      const int num = top[0]->num();
      const int count = top[0]->count();
      const int sub_count = count / num;
      CHECK_EQ(count, num * sub_count);
      const unsigned int* mask = static_cast<const unsigned int*>(rand_vec_.cpu_data());
      for(int n = 0; n < num; n++) {
        const int offset = top[0]->offset(n);
        const Dtype alpha = Dtype((mask[n] > uint_thres_) * scale_);
        caffe_gpu_scale(sub_count, alpha, top_diff + offset, bottom_diff + offset);
      }
    } else if(this->phase_ == TEST) {
      caffe_copy(top[0]->count(), top_diff, bottom_diff);
    } else {
      NOT_IMPLEMENTED;
    }
  }
}

INSTANTIATE_LAYER_GPU_FUNCS(SpatialDropoutLayer);


}  // namespace caffe
